val r = {foo = 2,bar = "asdf", idk = true}

datatype mytype = TwoInts of int*int
		| Str of string
		| Pizza

(* mytype -> int *)
(* case mathing must exhaust all cases and not redundant cases *)
fun f (x : mytype) =
  case x of
      Pizza => 3
    | Str s => String.size s
    | TwoInts(i1, i2) => i1+i2

datatype id = StudentNum of int
	    | Name of string
		      * (string option)
		      * string

datatype exp = Constant of int
	     | Negate of exp
	     | Add of exp * exp
	     | Multiply of exp * exp

(* Add (Constant (10+9), Negate (Constant (5))) *)

fun eval e =
  case e of
      Constant i        => i
    | Negate e2         => ~ (eval e2)
    | Add (e1, e2)      => (eval e1) + (eval e2)
    | Multiply (e1, e2) => (eval e1) * (eval e2)
					   
fun number_of_adds e = (* exp -> int *)
  case e of
      Constant i        => 0
    | Negate e2         => number_of_adds e2
    | Add (e1, e2)      => 1 + number_of_adds e1 + number_of_adds e2
    | Multiply (e1, e2) => number_of_adds e1 + number_of_adds e2
							      
fun max_constant e =
  case e of
      Constant i        => i
    | Negate e2         => max_constant e2
    | Add (e1, e2)      => Int.max(max_constant e1, max_constant e2)
    | Multiply (e1, e2) => Int.max(max_constant e1, max_constant e2)

datatype my_int_list = Empty
		     | Cons of int * my_int_list

fun append_my_list (xs,ys) =
  case xs of
      Empty => ys
    | Cons (x, xs') => Cons (x, append_my_list (xs', ys))

fun int_or_zero intoption =
  case intoption of
      NONE => 0
    | SOME i => i+1

fun sum_list xs =
  case xs of
      [] => 0
    | x::xs' => x + sum_list xs'

fun append (xs, ys) =
  case xs of
      [] => ys
    | x::xs' => x::append (xs', ys)

datatype 'a option  = NONE | SOME of 'a
datatype 'a mylist = Empty | Cons of 'a * 'a mylist
datatype ('a, 'b) tree = Leaf of 'b | Node 'a * ('a, 'b) tree * ('a, 'b) tree

(* type is (int, int) tree -> int *)
fun sum_tree tr =
  case tr of
      Leaf i => i
    | Node (i, left, right) => i + sum_tree left + sum_tree right

(* type is ('a int) tree -> 'a *)
fun sum_leaves tr = 					
  case tr of
      Leaf i => i
    | Node (i, left, right) => sum_leaves left + sum_leaves right

(* type is ('a, 'b) tree -> int *)
fun num_leaves tr =
  case tr of
      Leaf i => 1
   | Node (i, left, right) => num_leaves left + num_leaves right

		     
